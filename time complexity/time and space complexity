Notation	Name	Example	Notes
O(1)	Constant Time	Access array index, push/pop stack	Fastest possible
O(log n)	Logarithmic Time	Binary search, balanced BST search	Grows very slowly
O(n)	Linear Time	Traverse array, find max/min	Directly proportional to n
O(n log n)	Linearithmic Time	Merge sort, quicksort avg, heapsort	Typical for efficient sorts
O(nÂ²)	Quadratic Time	Nested loops over n elements	Often too slow for large n
O(nÂ³)	Cubic Time	Triple nested loops	Avoid for large n
O(2â¿)	Exponential Time	Subset generation, naive recursion in Fibonacci	Becomes huge very fast
O(n!)	Factorial Time	Traveling salesman brute force	Impractical for n > 10

ğŸ“Œ Space Complexity Chart
Notation	Example	Notes
O(1)	In-place swap, two-pointer algorithms	Minimal extra memory
O(log n)	Recursion depth in binary search	Often from divide & conquer
O(n)	Storing array, queue, DFS visited[]	Linear extra memory
O(n log n)	Segment trees, merge sort temp arrays	Common in advanced DS
O(nÂ²)	DP tables, adjacency matrix for dense graph	Memory heavy

ğŸ“Œ Common Algorithm Complexities
Algorithm / Operation	Time Complexity	Space Complexity
Array Access (index)	O(1)	O(1)
Array Search (linear)	O(n)	O(1)
Binary Search	O(log n)	O(1)
Sorting (Merge/Quick avg)	O(n log n)	O(log n) or O(n)
BFS / DFS (graph)	O(V + E)	O(V)
Dijkstra (PQ)	O((V + E) log V)	O(V + E)
Matrix Multiplication (naive)	O(nÂ³)	O(nÂ²)
Generating All Subsets	O(2â¿)	O(n)

ğŸ“Œ Growth Rate Intuition
O(1) â†’ constant, fastest

O(log n) â†’ doubles input, +1 step

O(n) â†’ doubles input, doubles steps

O(n log n) â†’ best you can get for sorting

O(nÂ²) & above â†’ dangerous for n > 10âµ

O(2â¿), O(n!) â†’ only feasible for very small n
